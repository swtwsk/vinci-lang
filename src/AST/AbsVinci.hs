

module AST.AbsVinci where

-- Haskell module generated by the BNF converter




newtype VIdent = VIdent String deriving (Eq, Ord, Show, Read)
newtype SIdent = SIdent String deriving (Eq, Ord, Show, Read)
newtype TPolyIdent = TPolyIdent String
  deriving (Eq, Ord, Show, Read)
data Program a = Prog a [Phrase a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Prog a phrases -> Prog (f a) (map (fmap f) phrases)
data Line a = Line a (Phrase a)
  deriving (Eq, Ord, Show, Read)

instance Functor Line where
    fmap f x = case x of
        Line a phrase -> Line (f a) (fmap f phrase)
data Phrase a
    = Value a (LetDef a)
    | Expression a (Expr a)
    | StructDecl a (StructDef a)
  deriving (Eq, Ord, Show, Read)

instance Functor Phrase where
    fmap f x = case x of
        Value a letdef -> Value (f a) (fmap f letdef)
        Expression a expr -> Expression (f a) (fmap f expr)
        StructDecl a structdef -> StructDecl (f a) (fmap f structdef)
data LetDef a = Let a [LetBind a] | LetRec a [LetBind a]
  deriving (Eq, Ord, Show, Read)

instance Functor LetDef where
    fmap f x = case x of
        Let a letbinds -> Let (f a) (map (fmap f) letbinds)
        LetRec a letbinds -> LetRec (f a) (map (fmap f) letbinds)
data LetBind a
    = ConstBind a (LetLVI a) (Expr a)
    | ProcBind a (ProcName a) [LetLVI a] (RType a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor LetBind where
    fmap f x = case x of
        ConstBind a letlvi expr -> ConstBind (f a) (fmap f letlvi) (fmap f expr)
        ProcBind a procname letlvis rtype expr -> ProcBind (f a) (fmap f procname) (map (fmap f) letlvis) (fmap f rtype) (fmap f expr)
data LetLVI a = LetLVI a (LambdaVI a)
  deriving (Eq, Ord, Show, Read)

instance Functor LetLVI where
    fmap f x = case x of
        LetLVI a lambdavi -> LetLVI (f a) (fmap f lambdavi)
data Expr a
    = EId a VIdent
    | EInt a Integer
    | EFloat a Double
    | ETrue a
    | EFalse a
    | EFieldGet a (Expr a) VIdent
    | EApp a (Expr a) (Expr a)
    | ETyped a (Expr a) (Type a)
    | ENeg a (Expr a)
    | ENot a (Expr a)
    | EMul a (Expr a) (Expr a)
    | EDiv a (Expr a) (Expr a)
    | EMod a (Expr a) (Expr a)
    | EAdd a (Expr a) (Expr a)
    | ESub a (Expr a) (Expr a)
    | ELTH a (Expr a) (Expr a)
    | ELE a (Expr a) (Expr a)
    | EGTH a (Expr a) (Expr a)
    | EGE a (Expr a) (Expr a)
    | EEQU a (Expr a) (Expr a)
    | ENE a (Expr a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
    | ECond a (Expr a) (Expr a) (Expr a)
    | ELetIn a (LetDef a) (Expr a)
    | ELambda a [LambdaVI a] (Expr a)
    | ETuple a (Expr a) [Expr a]
    | ENamedCons a SIdent [FieldDef a]
    | ECons a [FieldDef a]
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EId a vident -> EId (f a) vident
        EInt a integer -> EInt (f a) integer
        EFloat a double -> EFloat (f a) double
        ETrue a -> ETrue (f a)
        EFalse a -> EFalse (f a)
        EFieldGet a expr vident -> EFieldGet (f a) (fmap f expr) vident
        EApp a expr1 expr2 -> EApp (f a) (fmap f expr1) (fmap f expr2)
        ETyped a expr type_ -> ETyped (f a) (fmap f expr) (fmap f type_)
        ENeg a expr -> ENeg (f a) (fmap f expr)
        ENot a expr -> ENot (f a) (fmap f expr)
        EMul a expr1 expr2 -> EMul (f a) (fmap f expr1) (fmap f expr2)
        EDiv a expr1 expr2 -> EDiv (f a) (fmap f expr1) (fmap f expr2)
        EMod a expr1 expr2 -> EMod (f a) (fmap f expr1) (fmap f expr2)
        EAdd a expr1 expr2 -> EAdd (f a) (fmap f expr1) (fmap f expr2)
        ESub a expr1 expr2 -> ESub (f a) (fmap f expr1) (fmap f expr2)
        ELTH a expr1 expr2 -> ELTH (f a) (fmap f expr1) (fmap f expr2)
        ELE a expr1 expr2 -> ELE (f a) (fmap f expr1) (fmap f expr2)
        EGTH a expr1 expr2 -> EGTH (f a) (fmap f expr1) (fmap f expr2)
        EGE a expr1 expr2 -> EGE (f a) (fmap f expr1) (fmap f expr2)
        EEQU a expr1 expr2 -> EEQU (f a) (fmap f expr1) (fmap f expr2)
        ENE a expr1 expr2 -> ENE (f a) (fmap f expr1) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
        ECond a expr1 expr2 expr3 -> ECond (f a) (fmap f expr1) (fmap f expr2) (fmap f expr3)
        ELetIn a letdef expr -> ELetIn (f a) (fmap f letdef) (fmap f expr)
        ELambda a lambdavis expr -> ELambda (f a) (map (fmap f) lambdavis) (fmap f expr)
        ETuple a expr exprs -> ETuple (f a) (fmap f expr) (map (fmap f) exprs)
        ENamedCons a sident fielddefs -> ENamedCons (f a) sident (map (fmap f) fielddefs)
        ECons a fielddefs -> ECons (f a) (map (fmap f) fielddefs)
data LambdaVI a
    = TypedVId a (LambdaVI a) (Type a)
    | LambdaVId a VIdent
    | WildVId a
    | TupleVId a [LambdaVI a]
  deriving (Eq, Ord, Show, Read)

instance Functor LambdaVI where
    fmap f x = case x of
        TypedVId a lambdavi type_ -> TypedVId (f a) (fmap f lambdavi) (fmap f type_)
        LambdaVId a vident -> LambdaVId (f a) vident
        WildVId a -> WildVId (f a)
        TupleVId a lambdavis -> TupleVId (f a) (map (fmap f) lambdavis)
data FieldDef a = FieldDef a VIdent (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor FieldDef where
    fmap f x = case x of
        FieldDef a vident expr -> FieldDef (f a) vident (fmap f expr)
data ProcName a = ProcNameId a VIdent
  deriving (Eq, Ord, Show, Read)

instance Functor ProcName where
    fmap f x = case x of
        ProcNameId a vident -> ProcNameId (f a) vident
data StructDef a = SDef a SIdent [TPolyIdent] [FieldDecl a]
  deriving (Eq, Ord, Show, Read)

instance Functor StructDef where
    fmap f x = case x of
        SDef a sident tpolyidents fielddecls -> SDef (f a) sident tpolyidents (map (fmap f) fielddecls)
data FieldDecl a = FieldDecl a VIdent (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor FieldDecl where
    fmap f x = case x of
        FieldDecl a vident type_ -> FieldDecl (f a) vident (fmap f type_)
data Type a
    = TInt a
    | TFloat a
    | TBool a
    | TStruct a SIdent
    | TPoly a TPolyIdent
    | TFun a (Type a) (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        TInt a -> TInt (f a)
        TFloat a -> TFloat (f a)
        TBool a -> TBool (f a)
        TStruct a sident -> TStruct (f a) sident
        TPoly a tpolyident -> TPoly (f a) tpolyident
        TFun a type_1 type_2 -> TFun (f a) (fmap f type_1) (fmap f type_2)
data RType a = NoRetType a | RetType a (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor RType where
    fmap f x = case x of
        NoRetType a -> NoRetType (f a)
        RetType a type_ -> RetType (f a) (fmap f type_)
