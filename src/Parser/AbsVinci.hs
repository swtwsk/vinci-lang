-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Vinci.

module Parser.AbsVinci where

import qualified Data.String

data Program a = Prog a [Phrase a]
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data Phrase a
    = Value a (LetDef a)
    | Expression a (Expr a)
    | StructDecl a (StructDef a)
    | TypeSynon a SIdent (Type a)
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data LetDef a = Let a [LetBind a]
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data LetBind a
    = ConstBind a (LetLVI a) (Expr a)
    | ProcBind a (ProcName a) [LetLVI a] (RType a) (Expr a)
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data LetLVI a = LetLVI a (LambdaVI a)
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data Expr a
    = EId a VIdent
    | EInt a Integer
    | EFloat a Double
    | ETrue a
    | EFalse a
    | EFieldGet a (Expr a) VIdent
    | ETuple a (Expr a) [Expr a]
    | EApp a (Expr a) (Expr a)
    | ETyped a (Expr a) (Type a)
    | ENeg a (Expr a)
    | ENot a (Expr a)
    | EMul a (Expr a) (Expr a)
    | EDiv a (Expr a) (Expr a)
    | EMod a (Expr a) (Expr a)
    | EAdd a (Expr a) (Expr a)
    | ESub a (Expr a) (Expr a)
    | ELTH a (Expr a) (Expr a)
    | ELE a (Expr a) (Expr a)
    | EGTH a (Expr a) (Expr a)
    | EGE a (Expr a) (Expr a)
    | EEQU a (Expr a) (Expr a)
    | ENE a (Expr a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
    | ECond a (Expr a) (Expr a) (Expr a)
    | ELetIn a (LetDef a) (Expr a)
    | ELambda a [LambdaVI a] (Expr a)
    | ENamedCons a SIdent [FieldDef a]
    | ECons a [FieldDef a]
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data LambdaVI a
    = TypedVId a (LambdaVI a) (Type a)
    | LambdaVId a VIdent
    | WildVId a
    | TupleVId a [LambdaVI a]
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data FieldDef a = FieldDef a VIdent (Expr a)
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data ProcName a = ProcNameId a VIdent
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data StructDef a = SDef a SIdent [TPolyIdent] [FieldDecl a]
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data FieldDecl a = FieldDecl a VIdent (Type a)
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data Type a
    = TInt a
    | TFloat a
    | TBool a
    | TStruct a SIdent
    | TPoly a TPolyIdent
    | TFun a (Type a) (Type a)
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

data RType a = NoRetType a | RetType a (Type a)
    deriving (Ord, Show, Read, Functor, Foldable, Traversable)

newtype VIdent = VIdent String
    deriving (Eq, Ord, Show, Read, Data.String.IsString)

newtype SIdent = SIdent String
    deriving (Eq, Ord, Show, Read, Data.String.IsString)

newtype TPolyIdent = TPolyIdent String
    deriving (Eq, Ord, Show, Read, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = Maybe (Int, Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = Nothing

pattern BNFC'Position :: Int -> Int -> BNFC'Position
pattern BNFC'Position line col = Just (line, col)

-- EQs
instance Eq (Program a) where
    (Prog _ pl) == (Prog _ pr) = pl == pr

instance Eq (Phrase a) where
    (Value _ ll) == (Value _ lr) = ll == lr
    (Expression _ el) == (Expression _ er) = el == er
    (StructDecl _ sl) == (StructDecl _ sr) = sl == sr
    _ == _ = False

instance Eq (LetDef a) where
    (Let _ ll) == (Let _ lr) = ll == lr

instance Eq (LetBind a) where
    (ConstBind _ ll el) == (ConstBind _ lr er) = ll == lr && el == er
    (ProcBind _ pl ll rl el) == (ProcBind _ pr lr rr er) = 
        pl == pr && ll == lr && rl == rr && el == er
    _ == _ = False

instance Eq (LetLVI a) where
    (LetLVI _ lvl) == (LetLVI _ lvr) = lvl == lvr

instance Eq (Expr a) where
    (EId _ vl) == (EId _ vr) = vl == vr
    (EInt _ il) == (EInt _ ir) = il == ir
    (EFloat _ fl) == (EFloat _ fr) = fl == fr
    (ETrue _) == (ETrue _) = True
    (EFalse _) == (EFalse _) = True
    (EFieldGet _ el vl) == (EFieldGet _ er vr) = el == er && vl == vr
    (ETuple _ el exprsl) == (ETuple _ er exprsr) = el == er && exprsl == exprsr
    (EApp _ el1 el2) == (EApp _ er1 er2) = el1 == er1 && el2 == er2
    (ETyped _ el tl) == (ETyped _ er tr) = el == er && tl == tr
    (ENeg _ el) == (ENeg _ er) = el == er
    (ENot _ el) == (ENot _ er) = el == er
    (EMul _ el1 el2) == (EMul _ er1 er2) = el1 == er1 && el2 == er2
    (EDiv _ el1 el2) == (EDiv _ er1 er2) = el1 == er1 && el2 == er2
    (EMod _ el1 el2) == (EMod _ er1 er2) = el1 == er1 && el2 == er2
    (EAdd _ el1 el2) == (EAdd _ er1 er2) = el1 == er1 && el2 == er2
    (ESub _ el1 el2) == (ESub _ er1 er2) = el1 == er1 && el2 == er2
    (ELTH _ el1 el2) == (ELTH _ er1 er2) = el1 == er1 && el2 == er2
    (ELE _  el1 el2) == (ELE _  er1 er2) = el1 == er1 && el2 == er2
    (EGTH _ el1 el2) == (EGTH _ er1 er2) = el1 == er1 && el2 == er2
    (EGE _  el1 el2) == (EGE _  er1 er2) = el1 == er1 && el2 == er2
    (EEQU _ el1 el2) == (EEQU _ er1 er2) = el1 == er1 && el2 == er2
    (ENE _  el1 el2) == (ENE _  er1 er2) = el1 == er1 && el2 == er2
    (EAnd _ el1 el2) == (EAnd _ er1 er2) = el1 == er1 && el2 == er2
    (EOr _  el1 el2) == (EOr _  er1 er2) = el1 == er1 && el2 == er2
    (ECond _ cl el1 el2) == (ECond _ cr er1 er2) = 
        cl == cr && el1 == er1 && el2 == er2
    (ELetIn _ ll el) == (ELetIn _ lr er) = ll == lr && el == er
    (ELambda _ ll el) == (ELambda _ lr er) = ll == lr && el == er
    (ENamedCons _ sl fl) == (ENamedCons _ sr fr) = sl == sr && fl == fr
    (ECons _ fl) == (ECons _ fr) = fl == fr
    _ == _ = False

instance Eq (LambdaVI a) where
    (TypedVId _ ll tl) == (TypedVId _ lr tr) = ll == lr && tl == tr
    (LambdaVId _ vl) == (LambdaVId _ vr) = vl == vr
    (WildVId _) == (WildVId _) = True
    (TupleVId _ ll) == (TupleVId _ lr) = ll == lr
    _ == _ = False

instance Eq (FieldDef a) where
    (FieldDef _ vl el) == (FieldDef _ vr er) = vl == vr && el == er

instance Eq (ProcName a) where
    (ProcNameId _ vl) == (ProcNameId _ vr) = vl == vr

instance Eq (StructDef a) where
    (SDef _ sl tl fl) == (SDef _ sr tr fr) = sl == sr && tl == tr && fl == fr

instance Eq (FieldDecl a) where
    (FieldDecl _ vl tl) == (FieldDecl _ vr tr) = vl == vr && tl == tr

instance Eq (Type a) where
    (TInt _) == (TInt _) = True
    (TFloat _) == (TFloat _) = True
    (TBool _) == (TBool _) = True
    (TStruct _ sl) == (TStruct _ sr) = sl == sr
    (TPoly _ pl) == (TPoly _ pr) = pl ==  pr
    (TFun _ tl1 tl2) == (TFun _ tr1 tr2) = tl1 == tr1 && tl2 == tr2
    _ == _ = False

instance Eq (RType a) where
    (NoRetType _) == (NoRetType _) = True
    (RetType _ tl) == (RetType _ tr) = tl == tr
    _ == _ = False

-- | Get the start position of something.

class HasPosition a where
    hasPosition :: a -> BNFC'Position

instance HasPosition (Program BNFC'Position) where
    hasPosition = \case
        Prog p _ -> p

instance HasPosition (Phrase BNFC'Position) where
    hasPosition = \case
        Value p _ -> p
        Expression p _ -> p
        StructDecl p _ -> p
        TypeSynon p _ _ -> p

instance HasPosition (LetDef BNFC'Position) where
    hasPosition = \case
        Let p _ -> p

instance HasPosition (LetBind BNFC'Position) where
    hasPosition = \case
        ConstBind p _ _ -> p
        ProcBind p _ _ _ _ -> p

instance HasPosition (LetLVI BNFC'Position) where
    hasPosition = \case
        LetLVI p _ -> p

instance HasPosition (Expr BNFC'Position) where
    hasPosition = \case
        EId p _ -> p
        EInt p _ -> p
        EFloat p _ -> p
        ETrue p -> p
        EFalse p -> p
        EFieldGet p _ _ -> p
        ETuple p _ _ -> p
        EApp p _ _ -> p
        ETyped p _ _ -> p
        ENeg p _ -> p
        ENot p _ -> p
        EMul p _ _ -> p
        EDiv p _ _ -> p
        EMod p _ _ -> p
        EAdd p _ _ -> p
        ESub p _ _ -> p
        ELTH p _ _ -> p
        ELE p _ _ -> p
        EGTH p _ _ -> p
        EGE p _ _ -> p
        EEQU p _ _ -> p
        ENE p _ _ -> p
        EAnd p _ _ -> p
        EOr p _ _ -> p
        ECond p _ _ _ -> p
        ELetIn p _ _ -> p
        ELambda p _ _ -> p
        ENamedCons p _ _ -> p
        ECons p _ -> p

instance HasPosition (LambdaVI BNFC'Position) where
    hasPosition = \case
        TypedVId p _ _ -> p
        LambdaVId p _ -> p
        WildVId p -> p
        TupleVId p _ -> p

instance HasPosition (FieldDef BNFC'Position) where
    hasPosition = \case
        FieldDef p _ _ -> p

instance HasPosition (ProcName BNFC'Position) where
    hasPosition = \case
        ProcNameId p _ -> p

instance HasPosition (StructDef BNFC'Position) where
    hasPosition = \case
        SDef p _ _ _ -> p

instance HasPosition (FieldDecl BNFC'Position) where
    hasPosition = \case
        FieldDecl p _ _ -> p

instance HasPosition (Type BNFC'Position) where
    hasPosition = \case
        TInt p -> p
        TFloat p -> p
        TBool p -> p
        TStruct p _ -> p
        TPoly p _ -> p
        TFun p _ _ -> p

instance HasPosition (RType BNFC'Position) where
    hasPosition = \case
        NoRetType p -> p
        RetType p _ -> p
